#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, dgtl11, arm_sensor,     sensorQuadEncoder)
#pragma config(Sensor, I2C_1,  left_chassis,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  right_chassis,  sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           chassis_r1,    tmotorVex393_HBridge, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port2,           chassis_r2,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port3,           chassis_r3,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           arm_l1,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           arm_l2,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm_r2,        tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           chassis_l2,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port8,           chassis_l3,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           arm_r1,        tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          chassis_l1,    tmotorVex393_HBridge, openLoop, encoderPort, I2C_1)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)
#include "Mod_Vex_Comp_Control.c"
#include "motor.h"
#include "RerunFunctoins.c"
#include "Auton.c"

void
init( ) {
	strTeam = "Dank Geoffrey";
	bLCDAuton =
	bLCDUserControl = true;
}

const int kMaxNumberOfPages = 8;
const int kMinNumberOfPages = 1;
int iAuton = 0;
string rgSAuton[kMaxNumberOfPages] = {"LPush", "RPush", "LStat", "RStat", "LMogo5", "RMogo5", "LMogo10", "RMogo10"};

void
pre_auton( ) {
	bool bLCD = nLCDButtons != 0 ? true : false;
	if(bLCD) iAuton = 1;
	while( bLCD ) {
		if( nLCDButtons == 1 ) {
			iAuton = iAuton == kMinNumberOfPages ? kMaxNumberOfPages : iAuton - 1;
			waitForRelease( );
		}
		if( nLCDButtons == 4 ) {
			iAuton = iAuton == kMaxNumberOfPages ? kMinNumberOfPages : iAuton + 1;
			waitForRelease( );
		}
		if( nLCDButtons == 2 ) {
			bLCD = false;
			waitForRelease( );
		}

		displayLCDString( 0, 0, "Auton " );
		displayLCDString(0, 6, rgSAuton[iAuton - 1]);
		displayLCDCenteredString( 1, "<    Select    >");
		delay( 50 );
		clearLCDLines( );
	}
	clearAllEncoder( );
}

task
autonomous( ) {
	clearAllEncoder();
	switch(iAuton) {
		case 1:  bSide = false; push();     break;
		case 2:  bSide = true;  push();     break;
		case 3:  bSide = false; statGoal(); break;
		case 4:  bSide = true;  statGoal(); break;
		case 5:  bSide = false; mogoFive(); break;
		case 6:  bSide = true;  mogoFive(); break;
		case 7:  bSide = false; mogoTen();  break;
		case 8:  bSide = true;  mogoTen();  break;
		default: break;
	}
	auton( 0, 0, 0, 0, 0, 0 );
}

void
armControl( ) {
	static int  iOutput;
	static int  iDes;
	static bool bBraking;

	if(vexRT[Btn5D]||vexRT[Btn5U]) {
		bBraking = true;
		iDes = vexRT[Btn5D] ? 0 : (vexRT[Btn5U] ? 100 : 0);
	}

	if(vexRT[Btn6U]||vexRT[Btn6D]||vexRT[Btn8L]) {
		bBraking = false;
		iOutput = vexRT[Btn6U] ? 127 : (vexRT[Btn6D] ? -127 : (vexRT[Btn8L] ? -40 : 0));
	}
	else if(bBraking) {
		iOutput = iArmPID(iDes);
	}
	else {
		iOutput = 7;
	}
	arm(iOutput);
}

task
teleop( ) {
	while(true) {
		//~Chassis Control~//
		tank((vexRT[Ch3]), (vexRT[Ch2]));

		//~Arm Control~//
		armControl( );

		if(vexRT[Btn8D]) {
			while(vexRT[Btn8D]) {
				delay( 20 ); //Don't hog the CPU!
			}
			startTask(record);
		}
		if(vexRT[Btn8U]) {
			while(vexRT[Btn8U]) {
				delay( 20 ); //Don't hog the CPU!
			}
			SensorValue[arm_sensor] = 0;
		}

		delay( 20 ); //Don't hog the CPU!
	}
}
